{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":11404918256146582176,"abi":{"parameters":[{"name":"deck","type":{"kind":"array","length":52,"type":{"kind":"field"}},"visibility":"public"},{"name":"key","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":52,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"2":{"source":"use crate::cmp::Eq;\n\nunconstrained fn __get_shuffle_indices<T, let N: u32>(lhs: [T; N], rhs: [T; N]) -> [Field; N]\nwhere\n    T: Eq,\n{\n    let mut shuffle_indices: [Field; N] = [0; N];\n\n    let mut shuffle_mask: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut found = false;\n        for j in 0..N {\n            if ((shuffle_mask[j] == false) & (!found)) {\n                if (lhs[i] == rhs[j]) {\n                    found = true;\n                    shuffle_indices[i] = j as Field;\n                    shuffle_mask[j] = true;\n                }\n            }\n            if (found) {\n                continue;\n            }\n        }\n        assert(found == true, \"check_shuffle, lhs and rhs arrays do not contain equivalent values\");\n    }\n\n    shuffle_indices\n}\n\nunconstrained fn __get_index<let N: u32>(indices: [Field; N], idx: Field) -> Field {\n    let mut result = 0;\n    for i in 0..N {\n        if (indices[i] == idx) {\n            result = i as Field;\n            break;\n        }\n    }\n    result\n}\n\npub(crate) fn check_shuffle<T, let N: u32>(lhs: [T; N], rhs: [T; N])\nwhere\n    T: Eq,\n{\n    unsafe {\n        let shuffle_indices = __get_shuffle_indices(lhs, rhs);\n\n        for i in 0..N {\n            let idx = __get_index(shuffle_indices, i as Field);\n            assert_eq(shuffle_indices[idx], i as Field);\n        }\n        for i in 0..N {\n            let idx = shuffle_indices[i];\n            let expected = rhs[idx];\n            let result = lhs[i];\n            assert_eq(expected, result);\n        }\n    }\n}\n\nmod test {\n    use super::check_shuffle;\n    use crate::cmp::Eq;\n\n    struct CompoundStruct {\n        a: bool,\n        b: Field,\n        c: u64,\n    }\n    impl Eq for CompoundStruct {\n        fn eq(self, other: Self) -> bool {\n            (self.a == other.a) & (self.b == other.b) & (self.c == other.c)\n        }\n    }\n\n    #[test]\n    fn test_shuffle() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [2, 0, 3, 1, 4];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test]\n    fn test_shuffle_identity() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [0, 1, 2, 3, 4];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test(should_fail_with = \"check_shuffle, lhs and rhs arrays do not contain equivalent values\")]\n    fn test_shuffle_fail() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [0, 1, 2, 3, 5];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test(should_fail_with = \"check_shuffle, lhs and rhs arrays do not contain equivalent values\")]\n    fn test_shuffle_duplicates() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [0, 1, 2, 3, 3];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test]\n    fn test_shuffle_compound_struct() {\n        let lhs: [CompoundStruct; 5] = [\n            CompoundStruct { a: false, b: 0, c: 12345 },\n            CompoundStruct { a: false, b: -100, c: 54321 },\n            CompoundStruct { a: true, b: 5, c: 0xffffffffffffffff },\n            CompoundStruct { a: true, b: 9814, c: 0xeeffee0011001133 },\n            CompoundStruct { a: false, b: 0x155, c: 0 },\n        ];\n        let rhs: [CompoundStruct; 5] = [\n            CompoundStruct { a: false, b: 0x155, c: 0 },\n            CompoundStruct { a: false, b: 0, c: 12345 },\n            CompoundStruct { a: false, b: -100, c: 54321 },\n            CompoundStruct { a: true, b: 9814, c: 0xeeffee0011001133 },\n            CompoundStruct { a: true, b: 5, c: 0xffffffffffffffff },\n        ];\n        check_shuffle(lhs, rhs);\n    }\n}\n","path":"std/array/check_shuffle.nr"},"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n","path":"std/array/mod.nr"},"4":{"source":"unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n","path":"std/array/quicksort.nr"},"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"29":{"source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"37":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod schnorr;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod eddsa;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod ec;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(\n        crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y),\n    )\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\n","path":"std/lib.nr"},"70":{"source":"fn main(deck: pub [Field; 52], key: Field) -> pub [Field; 52] {\n    let result: [Field; 52] = deck.sort_via(|a, b| std::hash::pedersen_hash([a, key]).lt(std::hash::pedersen_hash([b, key])));\n    println(result);\n    result\n}\n","path":"/home/vcart/internship/dominion-starknet/circuits/shuffle/src/main.nr"}},"names":["main"],"brillig_names":["quicksort","decompose_hint","lt_32_hint","lte_16_hint","__get_shuffle_indices","__get_index","print_unconstrained","directive_invert"]}