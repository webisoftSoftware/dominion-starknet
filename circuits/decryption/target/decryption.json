{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":15465485505956910592,"abi":{"parameters":[{"name":"key","type":{"kind":"field"},"visibility":"private"},{"name":"card","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"37":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod schnorr;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod eddsa;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod ec;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(\n        crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y),\n    )\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\n","path":"std/lib.nr"},"70":{"source":"fn main(key: Field, card: [Field; 2]) -> pub Field {\n    let decoded_card = gmimc::bn254::dec::x5_2(card, key);\n    println(decoded_card[0]);\n    println(decoded_card[1]);\n    decoded_card[0]\n}\n\n","path":"/home/vcart/internship/dominion-starknet/circuits/decryption/src/main.nr"},"71":{"source":"use crate::bn254::consts;\nuse crate::decrypt;\n\n#[field(bn254)]\npub fn x5_2(mut x: [Field; 2], k: Field) -> [Field; 2] {\n    decrypt(consts::x5_2_config(), x, k)\n}\n\n#[field(bn254)]\npub fn x5_3(mut x: [Field; 3], k: Field) -> [Field; 3] {\n    decrypt(consts::x5_3_config(), x, k)\n}\n\n#[field(bn254)]\npub fn x5_4(mut x: [Field; 4], k: Field) -> [Field; 4] {\n    decrypt(consts::x5_4_config(), x, k)\n}\n\n#[field(bn254)]\npub fn x5_5(mut x: [Field; 5], k: Field) -> [Field; 5] {\n    decrypt(consts::x5_5_config(), x, k)\n}\n\n#[field(bn254)]\npub fn x5_6(mut x: [Field; 6], k: Field) -> [Field; 6] {\n    decrypt(consts::x5_6_config(), x, k)\n}\n\n#[field(bn254)]\npub fn x5_7(mut x: [Field; 7], k: Field) -> [Field; 7] {\n    decrypt(consts::x5_7_config(), x, k)\n}\n\n#[field(bn254)]\npub fn x5_8(mut x: [Field; 8], k: Field) -> [Field; 8] {\n    decrypt(consts::x5_8_config(), x, k)\n}\n\n#[field(bn254)]\npub fn x5_9(mut x: [Field; 9], k: Field) -> [Field; 9] {\n    decrypt(consts::x5_9_config(), x, k)\n}\n\n#[field(bn254)]\npub fn x5_10(mut x: [Field; 10], k: Field) -> [Field; 10] {\n    decrypt(consts::x5_10_config(), x, k)\n}\n\n#[field(bn254)]\npub fn x5_11(mut x: [Field; 11], k: Field) -> [Field; 11] {\n    decrypt(consts::x5_11_config(), x, k)\n}\n\n#[field(bn254)]\npub fn x5_12(mut x: [Field; 12], k: Field) -> [Field; 12] {\n    decrypt(consts::x5_12_config(), x, k)\n}\n\n#[field(bn254)]\npub fn x5_13(mut x: [Field; 13], k: Field) -> [Field; 13] {\n    decrypt(consts::x5_13_config(), x, k)\n}\n\n#[field(bn254)]\npub fn x5_14(mut x: [Field; 14], k: Field) -> [Field; 14] {\n    decrypt(consts::x5_14_config(), x, k)\n}\n\n#[field(bn254)]\npub fn x5_15(mut x: [Field; 15], k: Field) -> [Field; 15] {\n    decrypt(consts::x5_15_config(), x, k)\n}\n\n#[field(bn254)]\npub fn x5_16(mut x: [Field; 16], k: Field) -> [Field; 16] {\n    decrypt(consts::x5_16_config(), x, k)\n}\n","path":"/home/vcart/nargo/github.com/TaceoLabs/noir-GMiMCv0.4.0/src/bn254/dec.nr"},"75":{"source":"use dep::std::field::modulus_num_bits;\n\n/// Instantiations of GMiMC for prime field of the same order as BN254\npub mod bn254;\n\npub struct GmimcConfig<let R: u32> {\n    alpha: Field, // S-box power; depends on the underlying field\n    arc: [Field; R], // round constants\n}\n\npub fn config<let R: u32>(alpha: Field, arc: [Field; R]) -> GmimcConfig<R> {\n    GmimcConfig { alpha, arc }\n}\n\nfn round<let T: u32>(mut state: [Field; T], key: Field, alpha: Field, arc: Field) -> [Field; T] {\n    let sum = state[0] + key + arc;\n    let power = sum.pow_32(alpha);\n    for i in 1..T {\n        state[i] += power;\n    }\n    state\n}\n\nfn dec_round<let T: u32>(\n    mut state: [Field; T],\n    key: Field,\n    alpha: Field,\n    arc: Field,\n) -> [Field; T] {\n    let sum = state[0] + key + arc;\n    let power = sum.pow_32(alpha);\n    for i in 1..T {\n        state[i] -= power;\n    }\n    state\n}\n\nfn feistel_shift<let T: u32>(mut state: [Field; T]) -> [Field; T] {\n    let tmp = state[T - 1];\n    for i in 1..T {\n        state[T - i] = state[T - i - 1];\n    }\n    state[0] = tmp;\n    state\n}\n\nfn inv_feistel_shift<let T: u32>(mut state: [Field; T]) -> [Field; T] {\n    let tmp = state[0];\n    for i in 0..T - 1 {\n        state[i] = state[i + 1];\n    }\n    state[T - 1] = tmp;\n    state\n}\n\n// General GMiMC block cipher\npub fn encrypt<let T: u32, let R: u32>(\n    gmimc_conf: GmimcConfig<R>,\n    mut x: [Field; T],\n    k: Field,\n) -> [Field; T] {\n    // otherwise key is too small\n    assert(modulus_num_bits() as u16 >= 128);\n\n    let GmimcConfig { alpha, arc } = gmimc_conf;\n\n    for r in 0..R - 1 {\n        x = round(x, k, alpha, arc[r]);\n        x = feistel_shift(x);\n    }\n    x = round(x, k, alpha, arc[R - 1]);\n    x\n}\n\npub fn decrypt<let T: u32, let R: u32>(\n    gmimc_conf: GmimcConfig<R>,\n    mut x: [Field; T],\n    k: Field,\n) -> [Field; T] {\n    // otherwise key is too small\n    assert(modulus_num_bits() as u16 >= 128);\n\n    let GmimcConfig { alpha, arc } = gmimc_conf;\n\n    for r in 1..R {\n        x = dec_round(x, k, alpha, arc[R - r]);\n        x = inv_feistel_shift(x);\n    }\n    x = dec_round(x, k, alpha, arc[0]);\n    x\n}\n\n#[test]\nfn test_enc_x5_02() {\n    let x = [8654, 872364];\n    let k = 1246;\n    let cipher = bn254::enc::x5_2(x, k);\n    let plain = bn254::dec::x5_2(cipher, k);\n    assert(x == plain);\n}\n\n#[test]\nfn test_enc_x5_03() {\n    let x = [8654, 872364, 872634];\n    let k = 1246;\n    let cipher = bn254::enc::x5_3(x, k);\n    let plain = bn254::dec::x5_3(cipher, k);\n    assert(x == plain);\n}\n\n#[test]\nfn test_enc_x5_04() {\n    let x = [8654, 872364, 872634, 6723];\n    let k = 1246;\n    let cipher = bn254::enc::x5_4(x, k);\n    let plain = bn254::dec::x5_4(cipher, k);\n    assert(x == plain);\n}\n\n#[test]\nfn test_enc_x5_05() {\n    let x = [8654, 872364, 872634, 6723, 98234];\n    let k = 1246;\n    let cipher = bn254::enc::x5_5(x, k);\n    let plain = bn254::dec::x5_5(cipher, k);\n    assert(x == plain);\n}\n\n#[test]\nfn test_enc_x5_06() {\n    let x = [8654, 872364, 872634, 6723, 98234, 72394];\n    let k = 1246;\n    let cipher = bn254::enc::x5_6(x, k);\n    let plain = bn254::dec::x5_6(cipher, k);\n    assert(x == plain);\n}\n\n#[test]\nfn test_enc_x5_07() {\n    let x = [8654, 872364, 872634, 6723, 98234, 72394, 983745];\n    let k = 1246;\n    let cipher = bn254::enc::x5_7(x, k);\n    let plain = bn254::dec::x5_7(cipher, k);\n    assert(x == plain);\n}\n\n#[test]\nfn test_enc_x5_08() {\n    let x = [8654, 872364, 872634, 6723, 98234, 72394, 983745, 3289075];\n    let k = 1246;\n    let cipher = bn254::enc::x5_8(x, k);\n    let plain = bn254::dec::x5_8(cipher, k);\n    assert(x == plain);\n}\n\n#[test]\nfn test_enc_x5_09() {\n    let x = [8654, 872364, 872634, 6723, 98234, 72394, 983745, 3289075, 283974];\n    let k = 1246;\n    let cipher = bn254::enc::x5_9(x, k);\n    let plain = bn254::dec::x5_9(cipher, k);\n    assert(x == plain);\n}\n\n#[test]\nfn test_enc_x5_10() {\n    let x = [8654, 872364, 872634, 6723, 98234, 72394, 983745, 3289075, 283974, 2180734];\n    let k = 1246;\n    let cipher = bn254::enc::x5_10(x, k);\n    let plain = bn254::dec::x5_10(cipher, k);\n    assert(x == plain);\n}\n\n#[test]\nfn test_enc_x5_11() {\n    let x = [8654, 872364, 872634, 6723, 98234, 72394, 983745, 3289075, 283974, 2180734, 64];\n    let k = 1246;\n    let cipher = bn254::enc::x5_11(x, k);\n    let plain = bn254::dec::x5_11(cipher, k);\n    assert(x == plain);\n}\n\n#[test]\nfn test_enc_x5_12() {\n    let x = [8654, 872364, 872634, 6723, 98234, 72394, 983745, 3289075, 283974, 2180734, 64, 1212];\n    let k = 1246;\n    let cipher = bn254::enc::x5_12(x, k);\n    let plain = bn254::dec::x5_12(cipher, k);\n    assert(x == plain);\n}\n\n#[test]\nfn test_enc_x5_13() {\n    let x = [\n        8654, 872364, 872634, 6723, 98234, 72394, 983745, 3289075, 283974, 2180734, 64, 1212, 7893,\n    ];\n    let k = 1246;\n    let cipher = bn254::enc::x5_13(x, k);\n    let plain = bn254::dec::x5_13(cipher, k);\n    assert(x == plain);\n}\n\n#[test]\nfn test_enc_x5_14() {\n    let x = [\n        8654, 872364, 872634, 6723, 98234, 72394, 983745, 3289075, 283974, 2180734, 64, 1212, 7893,\n        4536,\n    ];\n    let k = 1246;\n    let cipher = bn254::enc::x5_14(x, k);\n    let plain = bn254::dec::x5_14(cipher, k);\n    assert(x == plain);\n}\n\n#[test]\nfn test_enc_x5_15() {\n    let x = [\n        8654, 872364, 872634, 6723, 98234, 72394, 983745, 3289075, 283974, 2180734, 64, 1212, 7893,\n        4536, 23,\n    ];\n    let k = 1246;\n    let cipher = bn254::enc::x5_15(x, k);\n    let plain = bn254::dec::x5_15(cipher, k);\n    assert(x == plain);\n}\n\n#[test]\nfn test_enc_x5_16() {\n    let x = [\n        8654, 872364, 872634, 6723, 98234, 72394, 983745, 3289075, 283974, 2180734, 64, 1212, 7893,\n        4536, 23, 53,\n    ];\n    let k = 1246;\n    let cipher = bn254::enc::x5_16(x, k);\n    let plain = bn254::dec::x5_16(cipher, k);\n    assert(x == plain);\n}\n","path":"/home/vcart/nargo/github.com/TaceoLabs/noir-GMiMCv0.4.0/src/lib.nr"}},"names":["main"],"brillig_names":["print_unconstrained"]}